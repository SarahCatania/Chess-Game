#include <string.h>
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

#include "AI.h"
#include "Board.h"
#include "Move.h"
#include "Setting.h"

Piece* chooseRandPiece(Piece* board[12][12])
{
	// RANDOM SELECTION OF BLACK PIECE
	int idNum = 0;
	int i;
	int j;
	idNum = rand() % 16;
	printf("ID NUM: %d \n", idNum);
	// FINDS THE PIECE WITH THAT RANDOM ID AND RETURNS IT
	for (i = 2; i < 10; i++)
	{
		for (j = 2; j < 10; j++)
		{
			if(board[i][j] != NULL)
			{
				if(board[i][j] -> idNum == idNum)
				{		
					printf("piece found");
					return board[i][j];
				}
			}
		}
	}
	return NULL;
}

// GENERATES ALL VALID CAPTURES AND RANDOMLY SELECTS ONE
int* higherValueCapture(Piece* movingPiece, Piece* board[12][12], int* capture)
{
	static int array[2];
	int numOfMoves = 0;
	int choice = 0;
	int pieceArr[10][4];
	srand(time(NULL));

	int i;
	int j;
	for (i = 2; i < 10; i++)
	{
		for (j = 2; j < 10; j++)
		{
			if (validMove(movingPiece, board[i][j], board, movingPiece -> x, movingPiece -> y, j, i) && board[i][j] != NULL)
			{
				printf ("valid and not empty \n");
				if (board[i][j] -> color == WHITE)
				{
					pieceArr[numOfMoves][0] = numOfMoves;
					pieceArr[numOfMoves][1] = i;
					pieceArr[numOfMoves][2] = j;
					pieceArr[numOfMoves][3] = board[i][j] -> type;
					*capture = 1;
					numOfMoves = numOfMoves + 1;
					//printf("queencapture\n");
				}
			}
		}
	} 

	if (*capture)
	{
		choice = rand() % numOfMoves;
		for (i = 0; i < numOfMoves; i++)
		{
			
			if (pieceArr[i][3] > pieceArr[choice][3])
			{
				choice = i;
			}
		}
		array[0] = pieceArr[choice][1];
		array[1] = pieceArr[choice][2];
	}
	return array;
}

void changeAIColor(Piece *board[12][12])
{
	int i = 0;
	int j = 0;

	for (i = 2; i < 10; i++)
	{
		for (j = 2; j < 10; j++)
		{
			if (i == 2 || i == 3)
			{
				board[i][j] -> idNum = 16;
			}
			else if (i == 8)
			{
				board[i][j] -> idNum = j - 2;
			}
			else if (i == 9)
			{
				board[i][j] -> idNum = j + 6;
			}
		}
	}
}

int* generateAIMove(Piece* movingPiece, Piece *board[12][12])
{
	//printf("hi");
	// MOVING PIECE RANDOM TYPE GENERATED BY chooseRandomPiece
	Type pieceType = movingPiece -> type;
	int randomChoice;
	int randomDistance;

	int rightLimit;
	int leftLimit;
	int topLimit;
	int bottomLimit;
	int diagonalLimit;

	int checkUpLeft = 0;
	int checkUpRight = 0;
	int higherUpRight = 0;

	Piece* pieceUpLeft;
	Piece* pieceUpRight;

	int capture = 0;

	// FINAL PIECE INTERNAL POSITION
	static int array[2];
	int* pieceArr;

	/*------------------------------- CASE FOR RANDOM PIECE -------------------------------*/
	switch (pieceType)
	{	
		/*------------------------------- PAWN -------------------------------*/
		case PAWN:
			// COLUMN SHOULD BE THE SAME IN THE FINAL AND INITIAL POSITION
			array[1] = movingPiece -> x;
			capture = 0;
			// CHECKING PIECES TO THE UPPER RIGHT AND LEFT OF THE BOARD
			pieceUpRight = board[movingPiece -> y + 1][movingPiece -> x + 1];
			pieceUpLeft = board[movingPiece -> y + 1][movingPiece -> x - 1];
		
			// MAKES SURE PIECES ARE NOT NULL SO COLOR CAN BE ACCESSED
			if (pieceUpRight != NULL)
			{
				checkUpRight = pieceUpRight -> color == WHITE;
				printf("checkupright %d\n", checkUpRight);
			}
			if (pieceUpLeft != NULL)
			{
				checkUpLeft = pieceUpLeft -> color == WHITE;
			}

			// CAPTURE FLAG FOR IF PIECES TO UPPER RIGHT OR UPPER LEFT ARE WHITE
			capture = (checkUpLeft) || (checkUpRight);
			if (capture)
			{
				printf("capture");
				array[0] = movingPiece -> y + 1;
				if ((checkUpLeft) && (checkUpRight))
				{
					higherUpRight = (pieceUpRight -> type) > (pieceUpLeft -> type);
					switch (higherUpRight)
					{
						case 0:
							array[1] = movingPiece -> x - 1;
							break;
						case 1:
							array[1] = movingPiece -> x + 1;
							break;
					}
				}
				else if(checkUpLeft)
				{
					array[1] = movingPiece -> x - 1;
				}
				else if(checkUpRight)
				{
					array[1] = movingPiece -> x + 1;
				}
			}
		
			// IF IT IS NOT THE FIRST TIME MOVING THE PIECE, CAN ONLY MOVE FORWARD ONCE
			if (movingPiece -> firstMove != 1)
			{
				array[0] = movingPiece -> y + 1;
			}
			else
			{
				// IF NOT FIRST TIME, RANDOMLY WILL MOVE FORWARD EITHER ONCE OR TWICE
		
				array[0] = movingPiece -> y + ((rand() % 2) + 1);
			//printf("%d FINAL Y INTERNAL", finaly);
			}
		break;
	
		/*------------------------------- KING -------------------------------*/
		case KING:
			capture = 0;
			if (board[movingPiece -> y + 1][movingPiece-> x] != NULL)
			{
				if (board[movingPiece -> y + 1][movingPiece-> x] -> color == WHITE)
				{
					capture = 1;
					array[0] = movingPiece -> y + 1;
					array[1] = movingPiece -> x;
				}
			}

			else if (board[movingPiece -> y - 1][movingPiece-> x] != NULL)
			{
				if (board[movingPiece -> y - 1][movingPiece-> x] -> color == WHITE)
				{
					capture = 1;
					array[0] = movingPiece -> y - 1;
					array[1] = movingPiece -> x;
				}
			}

			else if (board[movingPiece -> y][movingPiece-> x - 1] != NULL)
			{
				if (board[movingPiece -> y][movingPiece-> x - 1] -> color == WHITE)
				{
					capture = 1;
					array[0] = movingPiece -> y;
					array[1] = movingPiece -> x - 1;
				}
			}

			else if (board[movingPiece -> y][movingPiece-> x + 1] != NULL)
			{	
				if (board[movingPiece -> y][movingPiece-> x + 1] -> color == WHITE)
				{
					capture = 1;
					array[0] = movingPiece -> y;
					array[1] = movingPiece -> x + 1;
				}
			}

			else if (board[movingPiece -> y + 1][movingPiece-> x + 1] != NULL)
			{
				if (board[movingPiece -> y + 1][movingPiece-> x + 1] -> color == WHITE)
				{
					capture = 1;
					array[0] = movingPiece -> y + 1;
					array[1] = movingPiece -> x + 1;
				}
			}

			else if (board[movingPiece -> y - 1][movingPiece-> x + 1] != NULL)
			{
				if (board[movingPiece -> y - 1][movingPiece-> x + 1] -> color == WHITE)
				{
					capture = 1;
					array[0] = movingPiece -> y - 1;
					array[1] = movingPiece -> x + 1;
				}
			}

			else if (board[movingPiece -> y + 1][movingPiece-> x - 1] != NULL)
			{
				if (board[movingPiece -> y + 1][movingPiece-> x - 1] -> color == WHITE)
				{
					capture = 1;
					array[0] = movingPiece -> y + 1;
					array[1] = movingPiece -> x - 1;
				}
			}

			else if (board[movingPiece -> y - 1][movingPiece-> x - 1] != NULL)
			{
				if (board[movingPiece -> y - 1][movingPiece-> x - 1] -> color == WHITE)
				{
					capture = 1;
					array[0] = movingPiece -> y - 1;
					array[1] = movingPiece -> x - 1;
				}
			}

			// IF THERE IS NO CAPTURE OF OPPOSITE PIECE, MAKE A RANDOM MOVE
			randomChoice = (rand() % 8) + 1;
			if (!capture)
			{
				switch (randomChoice)
				{
					case 1:
						array[0] = movingPiece -> y + 1;
						array[1] = movingPiece -> x;
						break;
					case 2:
						array[0] = movingPiece -> y - 1;
						array[1] = movingPiece -> x;
						break;
					case 3:
						array[1] = movingPiece -> x + 1;
						array[0] = movingPiece -> y;
						break;
					case 4:
						array[1] = movingPiece -> x - 1;
						array[0] = movingPiece -> y;
						break;
					case 5:
						array[0] = movingPiece -> y + 1;
						array[1] = movingPiece -> x + 1;
						break;
					case 6:
						array[0] = movingPiece -> y - 1;
						array[1] = movingPiece -> x + 1;
						break;
					case 7:
						array[1] = movingPiece -> x - 1;
						array[0] = movingPiece -> y + 1;
						break;
					case 8:
						array[1] = movingPiece -> x - 1;
						array[0] = movingPiece -> y - 1;
						break;
					default:
						break;	
						
				}
			}
			break;

		/*------------------------------- KNIGHT -------------------------------*/
		case KNIGHT:
			capture = 0;
			if (board[movingPiece -> y + 2][movingPiece-> x + 1] != NULL)
			{
				if (board[movingPiece -> y + 2][movingPiece-> x + 1] -> color == WHITE)
				{
					capture = 1;
					array[0] = movingPiece -> y + 2;
					array[1] = movingPiece -> x + 1;
				}
			}	

			else if (board[movingPiece -> y + 1][movingPiece-> x + 2] != NULL)
			{
				if (board[movingPiece -> y + 1][movingPiece-> x + 2] -> color == WHITE)
				{
					capture = 1;
					array[0] = movingPiece -> y + 1;
					array[1] = movingPiece -> x + 2;
				}
			}

			else if (board[movingPiece -> y - 1][movingPiece-> x - 2] != NULL)
			{
				if (board[movingPiece -> y - 1][movingPiece-> x - 2] -> color == WHITE)
				{
					capture = 1;
					array[0] = movingPiece -> y - 1;
					array[1] = movingPiece -> x - 2;
				}
			}

			else if (board[movingPiece -> y - 2][movingPiece-> x - 1] != NULL)
			{
				if (board[movingPiece -> y - 2][movingPiece-> x - 1] -> color == WHITE)
				{
					capture = 1;
					array[0] = movingPiece -> y - 2;
					array[1] = movingPiece -> x - 1;
				}
			}

			else if (board[movingPiece -> y + 1][movingPiece-> x - 2] != NULL)
			{	
				if (board[movingPiece -> y + 1][movingPiece-> x - 2] -> color == WHITE)
				{
					capture = 1;
					array[0] = movingPiece -> y + 1;
					array[1] = movingPiece -> x - 2;
				}
			}

			else if (board[movingPiece -> y - 1][movingPiece-> x + 2] != NULL)
			{
				if (board[movingPiece -> y - 1][movingPiece-> x + 2] -> color == WHITE)
				{
					capture = 1;
					array[0] = movingPiece -> y - 1;
					array[1] = movingPiece -> x + 2;
				}
			}

			else if (board[movingPiece -> y + 2][movingPiece-> x - 1] != NULL)
			{
				if (board[movingPiece -> y + 2][movingPiece-> x - 1] -> color == WHITE)
				{
					capture = 1;
					array[0] = movingPiece -> y + 2;
					array[1] = movingPiece -> x - 1;
				}
			}

			else if (board[movingPiece -> y - 2][movingPiece-> x + 1] != NULL)
			{	
				if (board[movingPiece -> y - 2][movingPiece-> x + 1] -> color == WHITE)
				{
					capture = 1;
					array[0] = movingPiece -> y - 2;
					array[1] = movingPiece -> x + 1;
				}
			}

			if(!capture)
			{
				randomChoice = (rand() % 8) + 1;
				switch (randomChoice)
				{
					case 1:
						array[0] = movingPiece -> y + 2;
						array[1] = movingPiece -> x + 1;
						break;
					case 2:
						array[0] = movingPiece -> y + 1;
						array[1] = movingPiece -> x + 2;
						break;
					case 3:
						array[0] = movingPiece -> y - 1;
						array[1] = movingPiece -> x - 2;
						break;
					case 4:
						array[0] = movingPiece -> y - 2;
						array[1] = movingPiece -> x - 1;
						break;
					case 5:
						array[0] = movingPiece -> y + 1;
						array[1] = movingPiece -> x - 2;
						break;
					case 6:
						array[0] = movingPiece -> y - 1;
						array[1] = movingPiece -> x + 2;
						break;
					case 7:
						array[0] = movingPiece -> y + 2;
						array[1] = movingPiece -> x - 1;
						break;
					case 8:
						array[0] = movingPiece -> y - 2;
						array[1] = movingPiece -> x + 1;
						break;
					default:
						break;	
				}
			}
			break;

		/*------------------------------- BISHOP -------------------------------*/
		case BISHOP:
			capture = 0;


			pieceArr = higherValueCapture(movingPiece, board, &capture);

			if (capture)
			{
				array[0] = pieceArr[0];
				array[1] = pieceArr[1];
			}
	
			else
			{
				randomChoice = (rand() % 4) + 1;
				rightLimit = 10 - movingPiece -> x;
				leftLimit = movingPiece -> x - 1;
				topLimit = movingPiece -> y - 1;
				bottomLimit= 10 - movingPiece -> y;
				switch (randomChoice)
				{
					case 1:
						diagonalLimit = bottomLimit;
						if (rightLimit < bottomLimit)
							diagonalLimit = rightLimit;
						randomDistance = (rand() % diagonalLimit) + 1;
						array[0] = movingPiece -> y + randomDistance;
						array[1] = movingPiece -> x + randomDistance;
						break;
					case 2:
						diagonalLimit = topLimit;
						if (rightLimit < topLimit)
							diagonalLimit = rightLimit;
						randomDistance = (rand() % diagonalLimit) + 1;
						array[0] = movingPiece -> y - randomDistance;
						array[1] = movingPiece -> x + randomDistance;
						break;
					case 3:
						diagonalLimit = bottomLimit;
						if (leftLimit < bottomLimit)
							diagonalLimit = leftLimit;
						randomDistance = (rand() % diagonalLimit) + 1;
						array[0] = movingPiece -> y + randomDistance;
						array[1] = movingPiece -> x - randomDistance;
						break;
					case 4:
						diagonalLimit = topLimit;
						if (leftLimit < topLimit)
							diagonalLimit = leftLimit;
						randomDistance = (rand() % diagonalLimit) + 1;
						array[0] = movingPiece -> y - randomDistance;
						array[1] = movingPiece -> x - randomDistance;
						break;
					default:
						break;
				}
				break;
			}
			
			/*------------------------------- ROOK -------------------------------*/
			case ROOK:
				rightLimit = 10 - movingPiece -> x;
				leftLimit = movingPiece -> x - 1;
				topLimit = movingPiece -> y - 1;
				bottomLimit= 10 - movingPiece -> y;
				capture = 0;

				pieceArr = higherValueCapture(movingPiece, board, &capture);

				if (capture)
				{
					array[0] = pieceArr[0];
					array[1] = pieceArr[1];
				}

				else
				{
					randomChoice = (rand() % 4) + 1;
					switch (randomChoice)
					{
						case 1:
					
							randomDistance = (rand() % rightLimit) + 1;
							array[0] = movingPiece -> y;
							array[1] = movingPiece -> x  + randomDistance;
							break;
						case 2:
					
							randomDistance = (rand() % leftLimit) + 1;
							array[0] = movingPiece -> y;
							array[1] = movingPiece -> x - randomDistance;
							break;
						case 3:
					
							randomDistance = (rand() % bottomLimit) + 1;
							array[0] = movingPiece -> y + randomDistance;
							array[1] = movingPiece -> x;
				
							break;
						case 4:
					
							randomDistance = (rand() % topLimit) + 1;
							array[0] = movingPiece -> y - randomDistance;
							array[1] = movingPiece -> x;
							break;
						default:
							break;
					}
					break;
				}

		/*------------------------------- QUEEN -------------------------------*/
		case QUEEN:
			capture = 0;

			pieceArr = higherValueCapture(movingPiece, board, &capture);

			if (capture)
			{
				array[0] = pieceArr[0];
				array[1] = pieceArr[1];
			}
			
			else
			{
				randomChoice = (rand() % 8) + 1;
				rightLimit = 10 - movingPiece -> x;
				leftLimit = movingPiece -> x - 1;
				topLimit = movingPiece -> y - 1;
				bottomLimit= 10 - movingPiece -> y;
				switch (randomChoice)
				{
					case 1:
						randomDistance = (rand() % rightLimit) + 1;
						array[0] = movingPiece -> y;
						array[1] = movingPiece -> x  + randomDistance;
						break;
					case 2:
						randomDistance = (rand() % leftLimit) + 1;
						array[0] = movingPiece -> y;
						array[1] = movingPiece -> x - randomDistance;
						break;
					case 3:
						randomDistance = (rand() % bottomLimit) + 1;
						array[0] = movingPiece -> y + randomDistance;
						array[1] = movingPiece -> x;
						break;
					case 4:
						randomDistance = (rand() % topLimit) + 1;
						array[0] = movingPiece -> y - randomDistance;
						array[1] = movingPiece -> x;
						break;
					case 5:
						diagonalLimit = bottomLimit;
						if (rightLimit < bottomLimit)
							diagonalLimit = rightLimit;
						randomDistance = (rand() % diagonalLimit) + 1;
						array[0] = movingPiece -> y + randomDistance;
						array[1] = movingPiece -> x + randomDistance;
						break;
					case 6:
						diagonalLimit = bottomLimit;
						if (leftLimit < bottomLimit)
							diagonalLimit = leftLimit;
						randomDistance = (rand() % diagonalLimit) + 1;
						array[0] = movingPiece -> y + randomDistance;
						array[1] = movingPiece -> x - randomDistance;
						break;
					case 7:
						diagonalLimit = topLimit;
						if (rightLimit < topLimit)
							diagonalLimit = rightLimit;
						randomDistance = (rand() % diagonalLimit) + 1;
						array[0] = movingPiece -> y - randomDistance;
						array[1] = movingPiece -> x + randomDistance;
						break;
					case 8:
						diagonalLimit = topLimit;
						if (leftLimit < topLimit)
							diagonalLimit = leftLimit;
						randomDistance = (rand() % bottomLimit) + 1;
						array[0] = movingPiece -> y - randomDistance;
						array[1] = movingPiece -> x - randomDistance;
						break;
					default:
						break;
				}
				default:
					break;
			}


	}		
	// FINAL PIECE IS THE PIECE AT THE FINAL Y AND FINAL X LOCATION
	return array;
	
}

char* AIinput(Piece* movingPiece, int locationArray[2])
{
	static char AIinput [10];

	// CONVERTS INTEGER TO CHAR ON EXTERNAL BOARD
	AIinput[0] = (movingPiece -> x - 2) + 'a';
	AIinput[1] = (10 - movingPiece -> y) + '0';
	AIinput[2] = (locationArray[1] - 2)  + 'a';
	AIinput[3] = (10 - locationArray[0]) + '0';
	
	/*
	// DEBUGGING STATEMENTS
	printf("%d MOVING PIECE INTERN X \n", movingPiece -> x);
	printf("%d MOVING PIECE INTERN Y \n", movingPiece -> y);
	printf("%d FINAL PIECE INTERN X \n", locationArray[1]);
	printf("%d FINAL PIECE INTERN Y \n", locationArray[0]);
	printf("------------------\n");
	printf("%c MOVING PIECE EXTERN X \n", AIinput[0]);
	printf("%c MOVING PIECE EXTERN Y \n", AIinput[1]);
	printf("%c FINAL PIECE EXTERN X \n", AIinput[2]);
	printf("%c FINAL PIECE EXTERN Y \n", AIinput[3]);*/
	return AIinput;	
}

/*
int main()
{
	Piece *board[12][12];
	generateBoard(board);
	printBoard(board);
	Piece* movingPiece;
	int* locationArray;
	char* input;

	move(board, "e7e5");
	move(board, "a7a5");
	move(board, "b7b5");
	move(board, "c7c5");
	move(board, "d7d5");
	move(board, "f7f5");
	move(board, "g7g5");
	move(board, "h7h5");

	move(board, "c2c4");
	move(board, "b1c3");
	move(board, "c3d5");
	move(board, "f2f4");

	move(board, "f4g5");

	move(board, "b2b4");
	move(board, "b4a5");

	//move(board, "b2b4");
	//move(board, "b4b5");
	//move(board, "b5b6");
	//move(board, "g8f6");
	//move(board, "f8h6");
	printBoard(board);

	int validAIMove = 0;
	while (!validAIMove)
	{
		movingPiece = chooseRandPiece(board);
		locationArray = generateAIMove(movingPiece, board);
		input = AIinput(movingPiece, locationArray);
		validAIMove = move(board, input);
	}
	printBoard(board);

	//move(board, "d2d3");
	//printBoard(board);
	//move(board, "d3c4");
	//printBoard(board);

	validAIMove = 0;

	while (!validAIMove)
	{
		printf("before rand\n");
		movingPiece = chooseRandPiece(board);
		printf("hi\n");
		locationArray = generateAIMove(movingPiece, board);
		input = AIinput(movingPiece, locationArray);
		validAIMove = move(board, input);
	}
		
	//printBoard(board);
	return 0;	
}*/

/*
char[] AIMove()
{
	int moveFo
	while (!moveFound)
		
		if(validMove(movingPiece, finalPiece, intialX, intialY, finalX, finalY))
			return strncat(intialX, intialY, finalX, finalY)
}*/
